import path from "path"
import { ChunkExtractor } from "@loadable/server"
import serialize from "serialize-javascript"
import { ArtsyRequest, ArtsyResponse } from "Server/middleware/artsyExpress"
import { createRelaySSREnvironment } from "System/Relay/createRelaySSREnvironment"
import { AppRouteConfig } from "System/Router/Route"
import { createRouteConfig } from "System/Router/Utils/createRouteConfig"
import { findRoutesByPath } from "System/Router/Utils/findRoutesByPath"
import { matchingMediaQueriesForUserAgent } from "System/Router/Utils/matchingMediaQueriesForUserAgent"
import { queryStringParsing } from "System/Router/Utils/queryStringParsing"
import { buildServerAppContext } from "System/Router/buildServerAppContext"
import { renderStates } from "System/Router2/RenderStates"
import { RouterConfig } from "System/Router2/clientRouter"
import { MatchingMediaQueries, createMediaStyle } from "Utils/Responsive"
import { getUser } from "Utils/user"
import { NextFunction } from "express"
import { createQueryMiddleware } from "farce"
import { createRender } from "found"
import { Resolver } from "found-relay"
import {
  FarceElementResult,
  FarceRedirectResult,
  getFarceResult,
} from "found/server"
import qs from "qs"
import { Environment } from "react-relay"
import { getENV } from "Utils/getENV"
import { ServerStyleSheet } from "styled-components"
import { renderToString } from "react-dom/server"
import RelayServerSSR from "react-relay-network-modern-ssr/lib/server"
import { RelayNetworkLayerResponse } from "react-relay-network-modern"
import React from "react"
import { Boot } from "System/Router/Boot"

export interface ServerAppResolve {
  bodyHTML?: string
  redirect?: {
    url: string
  }
  status?: number
  scripts?: string
  headTags?: any[]
  styleTags?: string
}

export interface ServerRouterConfig extends RouterConfig {
  req: ArtsyRequest
  res: ArtsyResponse
  next: NextFunction
  routes: AppRouteConfig[]
  context?: {
    injectedData?: any
    relayEnvironment: Environment
  }
  /* For loadable-components bundle splitting */
  loadableFile?: string
  loadablePath?: string
  assetsPath?: string
}

export const setupServerRouter = async ({
  req,
  res,
  next,
  routes,
  context,
  ...config
}: ServerRouterConfig) => {
  await executeRouteHooks(req, res, next)

  const matchContext = buildServerAppContext(req, res, context)

  const userAgent = req.header("User-Agent") ?? ""

  const user = getUser(matchContext.user)

  const relayEnvironment = createRelaySSREnvironment({ user, userAgent })

  const historyMiddlewares = [
    createQueryMiddleware({
      parse: queryStringParsing,
      stringify: qs.stringify,
    }),
  ]

  const resolver = new Resolver(relayEnvironment)

  const render = createRender(renderStates)

  const routeConfig = createRouteConfig(routes)

  const farceResult = (await getFarceResult({
    url: req.url,
    historyMiddlewares,
    routeConfig,
    resolver,
    matchContext,
    render,
  })) as FarceElementResult | FarceRedirectResult

  const redirectResult = farceResult as FarceRedirectResult
  const elementResult = farceResult as FarceElementResult
  const redirect = redirectResult?.redirect

  // Redirect
  if (redirect) {
    return farceResult
  }

  const status = elementResult.status

  const headTags = [
    <style key="fresnel" type="text/css">
      {createMediaStyle()}
    </style>,
  ]

  const matchingMediaQueries = matchingMediaQueriesForUserAgent(userAgent)

  const ServerRouter: React.FC<{ tags: JSX.Element[] }> = ({ tags }) => {
    return (
      <Boot
        context={matchContext}
        headTags={tags}
        relayEnvironment={relayEnvironment}
        routes={routes}
        user={user}
        onlyMatchMediaQueries={matchingMediaQueries as MatchingMediaQueries}
      >
        {elementResult.element}
      </Boot>
    )
  }

  const { html, scripts, styleTags } = await collectAssets({
    ServerRouter,
    relayEnvironment,
  })

  return {
    headTags,
    html,
    redirect,
    scripts,
    status,
    styleTags,
  }
}

const executeRouteHooks = async (req, res, next) => {
  const matchedRoutes = findRoutesByPath({
    path: req.path,
  })

  for await (const route of matchedRoutes) {
    await route.onServerSideRender?.({
      req,
      res,
      next,
      route,
    })
  }
}

interface CollectAssetsProps {
  ServerRouter: React.FC
  relayEnvironment: Environment
}

const collectAssets = async ({
  ServerRouter,
  relayEnvironment,
}: CollectAssetsProps) => {
  const STATS = "loadable-stats.json"
  const PUBLIC_ASSET_PATH = "public/assets"
  const ASSET_PATH = "/assets"

  /**
   * This is the stats file generated by Force's webpack setup, via
   * @loadable/webpack-plugin.
   */
  const statsFile = (() => {
    try {
      return path.resolve(process.cwd(), PUBLIC_ASSET_PATH, STATS)
    } catch (error) {
      console.error(
        "[system/router/serverRouter.tsx] Error:",
        "Missing loadable-stats.json file"
      )
    }
  })()

  const assetPublicPath = (getENV("CDN_URL") ?? "") + ASSET_PATH

  const extractor = new ChunkExtractor({
    statsFile,
    entrypoints: [],
    publicPath: assetPublicPath,
  })

  const sheet = new ServerStyleSheet()

  const jsx = extractor.collectChunks(sheet.collectStyles(<ServerRouter />))

  const html = renderToString(jsx)

  const styleTags = sheet.getStyleTags()

  const relaySSRMiddleware = (relayEnvironment as any)
    .relaySSRMiddleware as RelayServerSSR

  const initialRelayData = await relaySSRMiddleware.getCache()

  // Remove excess hydration data
  initialRelayData.forEach(entry => {
    entry.forEach((item: RelayNetworkLayerResponse) => {
      delete item._res
    })
  })

  const relayData = serialize(
    serialize(initialRelayData, {
      isJSON: true,
    })
  )

  const scripts = [
    `<script>
      var __RELAY_BOOTSTRAP__ = ${relayData};
    </script>`,
    extractor
      .getScriptTags()
      .split("\n")
      .map(script => {
        /**
         * In production, prefix injected script src with CDN endpoint.
         * @see https://github.com/artsy/force/blob/main/src/lib/middleware/asset.ts#L23
         */
        if (getENV("CDN_URL")) {
          const scriptTagWithCDN = script.replace(
            /src="\/assets/g,
            `src="${assetPublicPath}`
          )

          return scriptTagWithCDN
        }

        return script
      })
      .filter(script => {
        return !(
          /**
           * Since these files are already embedded in our main
           * layout file, omit them from the scripts array.
           *
           * TODO: Don't include these files in the main layout
           * and instead relay on dynamically including them here.
           * Will require some shuffling in the jade template,
           * however.
           */
          (
            script.includes("/assets/runtime.") ||
            script.includes("/assets/artsy.") ||
            script.includes("/assets/common-artsy.") ||
            script.includes("/assets/common-react.") ||
            script.includes("/assets/common-utility.") ||
            script.includes("/assets/common.")
          )
        )
      })

      .join("\n"),
  ]

  return { html, scripts, styleTags, relayData }
}
