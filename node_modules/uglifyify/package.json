{
  "name": "uglifyify",
  "version": "3.0.1",
  "description": "A browserify transform which minifies your code using UglifyJS2",
  "main": "index.js",
  "dependencies": {
    "convert-source-map": "~0.2.3",
    "extend": "^1.2.1",
    "minimatch": "^0.3.0",
    "through": "~2.3.4",
    "uglify-js": "2.x.x"
  },
  "devDependencies": {
    "bl": "^0.9.3",
    "browserify": "^8.1.1",
    "from2": "^1.3.0",
    "tap-spec": "^2.1.2",
    "tape": "^3.2.0",
    "wrap-stream": "^2.0.0"
  },
  "scripts": {
    "test": "node test | tap-spec"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/hughsk/uglifyify.git"
  },
  "keywords": [
    "uglify",
    "minify",
    "compress",
    "compile",
    "browserify",
    "transform",
    "stream"
  ],
  "author": {
    "name": "Hugh Kennedy",
    "email": "hughskennedy@gmail.com",
    "url": "http://hughskennedy.com/"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "readme": "# uglifyify\n\nA [Browserify](http://browserify.org) v2 transform which minifies your code\nusing [UglifyJS2](https://github.com/mishoo/UglifyJS2).\n\n## Installation\n\n``` bash\nnpm install uglifyify\n```\n\n## Motivation/Usage\n\nOrdinarily you'd be fine doing this:\n\n``` bash\nbrowserify index.js | uglifyjs -c > bundle.js\n```\n\nBut uglifyify gives you the benefit applying Uglify's \"squeeze\" transform\n*before* it's processed by Browserify, meaning you can remove dead code paths\nfor conditional requires. Here's a contrived example:\n\n``` javascript\nif (true) {\n  module.exports = require('./browser')\n} else {\n  module.exports = require('./node')\n}\n```\n\n`module.exports = require('./node')` will be excluded by Uglify, meaning that\nonly `./browser` will be bundled and required.\n\nIf you combine uglifyify with [envify](http://github.com/hughsk/envify), you\ncan make this a little more accessible. Take this code:\n\n``` javascript\nif (process.env.NODE_ENV === 'development') {\n  module.exports = require('./development')\n} else {\n  module.exports = require('./production')\n}\n```\n\nAnd use this to compile:\n\n``` bash\nNODE_ENV=development browserify -t envify -t uglifyify index.js -o dev.js &&\nNODE_ENV=production browserify -t envify -t uglifyify index.js -o prod.js\n```\n\nIt should go without saying that you should be hesitant using environment\nvariables in a Browserify module - this is best suited to your own\napplications or modules built with Browserify's `--standalone` tag.\n\n## File Extensions\n\nSometimes, you don't want uglifyify to minify all of your files – for example,\nif you're using a transform to `require` CSS or HTML, you might get an error\nas uglify expects JavaScript and will throw if it can't parse what it's given.\n\nThis is done using the `-x` or `--exts` transform options, e.g. from the\ncommand-line:\n\n``` bash\nbrowserify     \\\n  -t coffeeify \\\n  -t [ uglifyify -x .js -x .coffee ]\n```\n\nThe above example will only minify `.js` and `.coffee` files, ignoring the rest.\n\n## Global Transforms\n\nYou might also want to take advantage of uglifyify's pre-bundle minification\nto produce slightly leaner files across your entire browserify bundle. By\ndefault, transforms only alter your application code, but you can use global\ntransforms to minify module code too. From your terminal:\n\n``` bash\nbrowserify -g uglifyify ./index.js > bundle.js\n```\n\nOr programatically:\n\n``` javascript\nvar browserify = require('browserify')\nvar fs = require('fs')\n\nvar bundler = browserify(__dirname + '/index.js')\n\nbundler.transform({\n  global: true\n}, 'uglifyify')\n\nbundler.bundle()\n  .pipe(fs.createWriteStream(__dirname + '/bundle.js'))\n```\n\nNote that this is fine for uglifyify as it shouldn't modify the behavior of\nyour code unexpectedly, but transforms such as envify should almost always\nstay local – otherwise you'll run into unexpected side-effects within modules\nthat weren't expecting to be modified as such.\n\n## Ignoring Files\n\nSometimes uglifyjs will break specific files under specific settings – it's\nrare, but does happen – and to work around that, you can use the `ignore`\noption. Given one or more glob patterns, you can filter out specific files\nthis way:\n\n``` bash\nbrowserify -g [ uglifyify --ignore '**/node_modules/weakmap/*' ] ./index.js\n```\n\n``` javascript\nvar bundler = browserify('index.js')\n\nbundler.transform({\n    global: true\n  , ignore: [\n      '**/node_modules/weakmap/*'\n    , '**/node_modules/async/*'\n  ]\n}, 'uglifyify')\n\nbundler.bundle().pipe(process.stdout)\n```\n\n## Source Maps\n\nUglifyify supports source maps, so you can minify your code and still see the\noriginal source – this works especially well with a tool such as\n[exorcist](https://github.com/thlorenz/exorcist) when creating production\nbuilds.\n\nSource maps are enabled when:\n\n* You're using another transform, such as\n  [coffeeify](https://github.com/jnordberg/coffeeify), that inlines source maps.\n* You've passed the `--debug` flag (or `debug` option) to your browserify\n  bundle.\n\nEnabling `--debug` with browserify is easy:\n\n``` bash\nbrowserify -t uglifyify --debug index.js\n```\n``` javascript\nvar bundler = browserify({ debug: true })\n\nbundler\n  .add('index.js')\n  .transform({ sourcemap: false }, 'uglifyify')\n  .bundle()\n  .pipe(process.stdout)\n```\n\nIf you'd prefer them not to be included regardless, you can opt out\nusing the `sourcemap` option:\n\n``` bash\nbrowserify -t [ uglifyify --no-sourcemap ] app.js\n```\n``` javascript\nvar bundler = browserify('index.js')\n\nbundler.transform({ sourcemap: false }, 'uglifyify')\n  .bundle()\n  .pipe(process.stdout)\n```\n",
  "bugs": {
    "url": "https://github.com/hughsk/uglifyify/issues"
  },
  "homepage": "https://github.com/hughsk/uglifyify",
  "_id": "uglifyify@3.0.1",
  "_shasum": "89dd6467e3a33875b78c35d81055f5bd21716057",
  "_from": "uglifyify@*",
  "_resolved": "https://registry.npmjs.org/uglifyify/-/uglifyify-3.0.1.tgz"
}
