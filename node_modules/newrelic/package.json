{
  "name": "newrelic",
  "version": "1.2.0",
  "author": {
    "name": "New Relic Node.js agent team",
    "email": "nodejs@newrelic.com"
  },
  "licenses": [
    {
      "type": "proprietary",
      "url": "https://raw.github.com/newrelic/node-newrelic/master/LICENSE"
    }
  ],
  "contributors": [
    {
      "name": "Saxon D'Aubin",
      "email": "saxon@newrelic.com",
      "url": "http://newrelic.com"
    },
    {
      "name": "Forrest L Norvell",
      "email": "forrest@newrelic.com",
      "url": "http://newrelic.com/"
    },
    {
      "name": "Jacob Groundwater",
      "email": "jacob@newrelic.com",
      "url": "https://newrelic.com"
    }
  ],
  "description": "New Relic agent",
  "keywords": [
    "apm",
    "performance",
    "monitoring",
    "instrumentation",
    "debugging",
    "profiling"
  ],
  "homepage": "http://github.com/newrelic/node-newrelic",
  "engines": {
    "node": ">=0.6.0"
  },
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "bunyan": "0.14.6",
    "continuation-local-storage": "2.6.2"
  },
  "devDependencies": {
    "mocha": "*",
    "chai": "*",
    "cover": "*",
    "request": "*",
    "sinon": "*",
    "architect": "*",
    "wrench": "*",
    "carrier": "*",
    "restify": "*",
    "tap": "*",
    "memcached": "*",
    "sequelize": "*",
    "redis": "*",
    "q": "*",
    "qx": "*",
    "nave": "*",
    "should": "*",
    "nock": "*",
    "split": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/newrelic/node-newrelic.git"
  },
  "readme": "[![npm status badge](https://nodei.co/npm/newrelic.png?stars=true&downloads=true)](https://nodei.co/npm/newrelic/)\n\n# New Relic for Node.js\n\nThis package instruments your application for performance monitoring\nwith [New Relic](http://newrelic.com).\n\nThis is a new product. You should try it in your staging or development\nenvironment first to verify it works for you.\n\nMake sure you have a [New Relic account](http://newrelic.com) before\nstarting. To see all the features, such as slow transaction traces, you will\nneed a New Relic Pro subscription (or equivalent).\n\n## Table of contents\n\n* [Getting started](#getting-started)\n* [Transactions and request naming](#transactions-and-request-naming)\n* [Configuration](#configuring-the-agent)\n* [Security](#security)\n* [Contributions](#contributions)\n* [Known issues](#known-issues)\n\n## Getting started\n\n1. [Install node](http://nodejs.org/#download). For now, at least 0.8 is\n   required. Some features (e.g. error tracing) depend in whole or in\n   part on features in 0.10 and above. Development work on the agent is\n   being done against the latest released non-development version of Node.\n2. Install this module via `npm install newrelic` for the application you\n   want to monitor.\n3. Copy `newrelic.js` from `node_modules/newrelic` into the root directory of\n   your application.\n4. Edit `newrelic.js` and replace `license_key`'s value with the license key\n   for your account.\n5. Add `require('newrelic');` as the first line of the app's main module.\n\nIf you wish to keep the configuration for the agent separate from your\napplication, the agent will look for newrelic.js in the directory referenced\nby the environment variable `NEW_RELIC_HOME` if it's set.\n\nWhen you start your app, the agent should start up with it and start reporting\ndata that will appear within [the New Relic UI](https://rpm.newrelic.com/)\nafter a few minutes. Because the agent minimizes the amount of bandwidth it\nconsumes, it only reports data once a minute, so if you add the agent to tests\nthat take less than a minute to run, the agent won't have time to report data\nto New Relic. The agent will write its log to a file named `newrelic_agent.log`\nin the application directory. If the agent doesn't send data or crashes your\napp, the log can help New Relic determine what went wrong, so be sure to send\nit along with any bug reports or support requests.\n\n## Transactions and request naming\n\nIn order to get the most value out of the New Relic agent for Node.js, you may\nhave to do a little work to help us figure out how your application is\nstructured. New Relic works on the assumption that it can group requests to\nyour application into transactions, which are defined by giving one or more\nrequest paths a name. These names are used to visualize where your app is\nspending its time (in transaction breakdowns), to identify slow requests, and\nto group scoped metrics, to tell you which portions of your application are,\nfor example, suffering from slow database performance.\n\nIf you're using Express or Restify with their default routers and are satisfied\nwith your application being represented by those frameworks' route names, you\nmay not need to do anything. However, if you want more specific names than are\nprovided by your framework, you may want to use one or more of the tools\ndescribed further on.\n\nThe simplest way to tell that you need to read further in this document is if\nyou feel too many of your requests are being lumped together under the\ncatch-all name `/*`. All requests that aren't otherwise named by the agent will\nend up grouped under `/*`.\n\n### Background\n\nIf you've been working with Node for a while, you're probably accustomed to\nthinking of your application's requests in terms of raw URLs. One of the great\nthings about Node is that it makes it so easy and simple to work with HTTP, and\nthat extends to things like parsing URLs and creating your own strategies for\nnaming and routing requests for services like RESTful APIs. This presents a\nchallenge for us, because we need to keep the number of names we're tracking\nsmall enough that we can keep the New Relic user experience snappy, and also so\nwe don't overwhelm you with so much data that it's difficult for you to see the\nproblem spots in your applications. URLs are not a good fit for how New Relic\nsees performance.\n\nAnother of Node's great strengths is that it provides a lot of tools that build\non top of the `http` module to simplify writing web services. Unfortunately,\nthat variety greatly complicates things for us, with our limited resources, and\nso we offer a few different tools to help you give us the information we need\nto provide you useful metrics about your application:\n\n* we can read the route names from the Express and Restify routers, if you're\n  using them (and as said above, for many of you, this may be all you need)\n* we offer an API for naming the current request, either with simple names or,\n  if you prefer, grouped into controllers with actions\n* and we support rules stored in your agent's configuration that can mark\n  requests to be renamed or ignored based on regular expressions matched\n  against the request's raw URLs (also available as API calls)\n\nLet's go through those tools one at a time.\n\n### Router introspection\n\nExpress is the most popular web framework in use within the Node community, and\na number of important services are also using Restify. Both frameworks map\nroutes to handlers, and both use a similar pattern to do so: they match one or\nmore HTTP methods (e.g. `GET` or the ever-popular `OPTIONS` – let's hear it\nfor CORS) along with a potentially parameterized path (e.g. `/user/:id`) or a\nregular expression (e.g.  `/^/user/([-0-9a-f]+)$/`). The New Relic agent will\ncapture both those pieces of information in the request name. If you have\nsupport for slow transaction traces and have enabled `capture_params`, the\ntransaction trace will also have the request's parameters and their values\nattached to it.\n\nThe only important thing to know about New Relic's support for Express and\nRestify is that if you're dissatisfied with the names it comes up with, you can\nuse the API calls described below to come up with more descriptive names. Also,\nif you use a different web framework or router and would like to see support\nfor it added, please let us know.\n\n### Request naming with the module API\n\nThe API is what's handed back from `require('newrelic')`, so\n\n```javascript\nvar newrelic = require('newrelic');\n```\n\nis all you need. Please note that you still need to ensure that loading the New\nRelic module is the first thing your application does, as it needs to bootstrap\nitself before the rest of your application loads, but you can safely require\nthe module from multiple modules in your application – it will only initialize\nitself once.\n\n#### newrelic.setTransactionName(name)\n\nName the current request. You can call this function anywhere within the\ncontext of an HTTP request handler, at any time after handling of the request\nhas started, but before the request has finished. A good rule of thumb is that\nif the request and response objects are in scope, you can set the name.\n\nExplicitly calling `newrelic.setTransactionName()` will override any names set\nby Express or Restify routes. Calls to `newrelic.setTransactionName()` and\n`newrelic.setControllerName()` will overwrite each other. The last one to run\nbefore the request ends wins.\n\n**VERY IMPORTANT NOTE:** Do not include highly variable information like GUIDs,\nnumerical IDs, or timestamps in the request names you create. If your request\nis slow enough to generate a transaction trace, that trace will contain the\noriginal URL. If you enable parameter capture, the parameters will also be\nattached to the trace. The request names are used to group requests for New\nRelic's many charts and tables, and those visualizations' value drops as the\nnumber of different request names increases. If you have 50 or so different\ntransaction names, you're probably pushing it. If you have more than a couple\nhundred, you need to rethink your naming strategy.\n\n#### newrelic.setControllerName(name, [action])\n\nName the current request using a controller-style pattern, optionally including\nthe current controller action. If the action is omitted, New Relic will include\nthe HTTP method (e.g. `GET`, `POST`) as the action. The rules for when you can\ncall `newrelic.setControllerName()` are the same as they are for\n`newrelic.setTransactionName()`.\n\nExplicitly calling `newrelic.setControllerName()` will override any names set\nby Express or Restify routes. Calls to `newrelic.setTransactionName()` and\n`newrelic.setControllerName()` will overwrite each other. The last one to run\nbefore the request ends wins.\n\nSee the above note on `newrelic.setTransactionName()`, which also applies to\nthis function.\n\n### Rules for naming and ignoring requests\n\nIf you don't feel like putting calls to the New Relic module directly into your\napplication code, you can use pattern-based rules to name requests. There are\ntwo sets of rules: one for renaming requests, and one to mark requests to be\nignored by New Relic's instrumentation.\n\nIf you're using socket.io, you will have a use case for ignoring rules right\nout of the box. You'll probably want to add a rule like the following:\n\n```javascript\n// newrelic.js\nexports.config = {\n  // other configuration\n  rules : {\n    ignore : [\n      '^/socket.io/.*/xhr-polling'\n    ]\n  }\n};\n```\n\nThis will keep socket.io long-polling from dominating your response-time\nmetrics and blowing out the apdex metrics for your application.\n\n#### rules.name\n\nA list of rules of the format `{pattern : \"pattern\", name : \"name\"}` for\nmatching incoming request URLs to `pattern` and naming the matching New Relic\ntransactions `name`. The pattern can be set as either a string or a JavaScript\nregular expression literal. Both pattern and name are required. Additional\nattributes are ignored.\n\nCan also be set via the environment variable `NEW_RELIC_NAMING_RULES`, with\nmultiple rules passed in as a list of comma-delimited JSON object literals:\n`NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}'`\n\n#### rules.ignore\n\nA list of patterns for matching incoming request URLs to be ignored. Patterns\nmay be strings or regular expressions.\n\nCan also be set via the environment variable `NEW_RELIC_IGNORING_RULES`, with\nmultiple rules passed in as a list of comma-delimited patterns:\n`NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me'` Note that\ncurrently there is no way to escape commas in patterns.\n\n### API for adding naming and ignoring rules\n\n#### newrelic.addNamingRule(pattern, name)\n\nProgrammatic version of `rules.name` above. Naming rules can not be removed\nuntil the Node process is restarted. They can also be added via the agent's\nconfiguration. Both parameters are mandatory.\n\n#### newrelic.addIgnoringRule(pattern)\n\nProgrammatic version of `rules.ignore` above. Ignoring rules can not be removed\nuntil the Node process is restarted. They can also be added via the agent's\nconfiguration. The pattern is mandatory.\n\n### Other API calls\n\n#### newrelic.setIgnoreTransaction(ignored)\n\nTell the module explicitly whether or not a given request should be ignored.\nAllows you to explicitly filter out long-polling routes or requests you know\nare going to be time-consuming in an uninteresting way, and also allows you\nto gather metrics for requests that would otherwise be ignored. Note that\nto prevent a transaction from being ignored with this function, you **must**\npass `false` as the parameter – in this case `null` or `undefined` will be\nignored.\n\n#### newrelic.noticeError(error)\n\nIf your app is doing its own error handling with domains or try/catch clauses,\nbut you want all of the information about how many errors are coming out of the\napp to be centrally managed, use this call. Unlike most of the calls here, this\ncall can be used outside of route handlers, but will have additional context if\ncalled from within transaction scope.\n\n### The fine print\n\nThis is the Node-specific version of New Relic's transaction naming API\ndocumentation. The naming API exists to help us deal with the very real problem\nthat trying to handle too many metrics will make New Relic slow for everybody,\nnot just the account with too many metrics. If, in conversation with New Relic\nSupport, you see discussion of \"metric explosion\", this is what they're talking\nabout.\n\nWhile we have a variety of strategies for dealing with these issues, the most\nsevere is simply to blacklist offending applications. The main reason for you\nto be careful in using our request-naming tools is to prevent that from\nhappening to your applications. We will do everything in our power to ensure\nthat you have a good experience with New Relic even if your application is\ncausing us trouble, but sometimes this will require manual intervention on the\npart of our team, and this can take a little while.\n\n## Configuring the agent\n\nThe agent can be tailored to your app's requirements, both from the server and\nvia the newrelic.js configuration file you created. For complete details on\nwhat can be configured, refer to\n[`lib/config.default.js`](https://github.com/newrelic/node-newrelic/blob/master/lib/config.default.js),\nwhich documents the available variables and their default values.\n\nIn addition, for those of you running in PaaS environments like Heroku or\nMicrosoft Azure, all of the configuration variables in `newrelic.js` have\ncounterparts that can be set via environment variables. You can mix and match\nvariables in the configuration file and environment variables freely;\nenvironment variables take precedence.\n\nHere's the list of the most important variables and their values:\n\n* `NEW_RELIC_LICENSE_KEY`: Your New Relic license key. This is a required\n  setting with no default value.\n* `NEW_RELIC_APP_NAME`: The name of this application, for reporting to\n  New Relic's servers. This value can be also be a comma-delimited list of\n  names. This is a required setting with no default value. (NOTE: as a\n  convenience to Azure users, the agent will use `APP_POOL_ID` as the\n  application name if it's set, so you can use the name you chose for\n  your Azure Web Server without setting it twice.)\n* `NEW_RELIC_NO_CONFIG_FILE`: Inhibit loading of the configuration file\n  altogether. Use with care. This presumes that all important configuration\n  will be available via environment variables, and some log messages\n  assume that a config file exists.\n* `NEW_RELIC_HOME`: path to the directory in which you've placed newrelic.js.\n* `NEW_RELIC_LOG`: Complete path to the New Relic agent log, including\n  the filename. The agent will shut down the process if it can't create\n  this file, and it creates the log file with the same umask of the\n  process. Setting this to `stdout` will write all logging to stdout, and\n  `stderr` will write all logging to stderr.\n* `NEW_RELIC_LOG_LEVEL`: Logging priority for the New Relic agent. Can be one of\n  `error`, `warn`, `info`, `debug`, or `trace`. `debug` and `trace` are\n  pretty chatty; unless you're helping New Relic figure out irregularities\n  with the agent, you're probably best off using `info` or higher.\n\nFor completeness, here's the rest of the list:\n\n* `NEW_RELIC_ENABLED`: Whether or not the agent should run. Good for\n  temporarily disabling the agent while debugging other issues with your\n  code. It doesn't prevent the agent from bootstrapping its instrumentation\n  or setting up all its pieces, it just prevents it from starting up or\n  connecting to New Relic's servers. Defaults to true.\n* `NEW_RELIC_ERROR_COLLECTOR_ENABLED`: Whether or not to trace errors within\n  your application. Values are `true` or `false`. Defaults to true.\n* `NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES`: Comma-delimited list of HTTP\n  status codes to ignore. Maybe you don't care if payment is required? Ignoring\n  a status code means that the transaction is not renamed to match the code,\n  and the request is not treated as an error by the error collector. Defaults\n  to ignoring 404.\n* `NEW_RELIC_IGNORE_SERVER_CONFIGURATION`: Whether to ignore server-side\n  configuration for this application. Defaults to false.\n* `NEW_RELIC_TRACER_ENABLED`: Whether to collect and submit slow\n  transaction traces to New Relic. Values are `true` or `false`. Defaults to\n  true.\n* `NEW_RELIC_TRACER_THRESHOLD`: Duration (in seconds) at which a transaction\n  trace will count as slow and be sent to New Relic. Can also be set to\n  `apdex_f`, at which point it will set the trace threshold to 4 times the\n  current ApdexT.\n* `NEW_RELIC_APDEX`: Set the initial Apdex tolerating / threshold value in\n  seconds.  This is more often than not set from the server. Defaults to 0.100.\n* `NEW_RELIC_CAPTURE_PARAMS`: Whether to capture request parameters on\n  slow transaction or error traces. Defaults to false.\n* `NEW_RELIC_IGNORED_PARAMS`: Some parameters may contain sensitive\n  values you don't want being sent out of your application. This setting\n  is a comma-delimited list of names of parameters to ignore. Defaults to\n  empty.\n* `NEW_RELIC_NAMING_RULES`: A list of comma-delimited JSON object literals:\n  `NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}'`\n  See the section on request and transaction naming for details. Defaults to\n  empty.\n* `NEW_RELIC_IGNORING_RULES`: A list of comma-delimited patterns:\n  `NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me'` Note that\n  currently there is no way to escape commas in patterns. Defaults to empty.\n* `NEW_RELIC_TRACER_TOP_N`: Increase this number to increase the diversity\n  of slow transaction traces sent to New Relic. Defaults to 1. See the\n  description in `lib/config.default.js`, as this feature is exceedingly hard\n  to summarize.\n* `NEW_RELIC_HOST`: Hostname for the New Relic collector proxy. You\n  shouldn't need to change this.\n* `NEW_RELIC_PORT`: Port number on which the New Relic collector proxy\n  will be listening. You shouldn't need to change this either.\n* `NEW_RELIC_DEBUG_METRICS`: Whether to collect internal supportability\n  metrics for the agent. Don't mess with this unless New Relic asks you to.\n* `NEW_RELIC_DEBUG_TRACER`: Whether to dump traces of the transaction tracer's\n  internal operation. It's unlikely to be informative unless you're a New Relic\n  Node.js engineer and it has a significant performance cost, so use with care.\n\n## Security\n\nWe take security (and the protection of your and your users' privacy) very\nseriously. See SECURITY.md for details, but the brief version is that if you\nfeel you've found a security issue in New Relic for Node, contact us at\nsecurity@newrelic.com.\n\n## Contributions\n\nWe owe a debt to all of the beta testers and users who have provided us with\nfeedback, and in some cases significant pieces of code. (If you wish to\ncontribute, please see CONTRIBUTING.md in this directory.) In particular, we're\nindebted to these people:\n\n* Hernan Silberman, for his work on the memcached instrumentation.\n* Jeff Howell &lt;jhowell@kabam.com&gt;, for coming up with a much simpler way\n  to instrument node-mongodb-native, as well as pointing out a problem with the\n  Connect instrumentation.\n\n## Recent changes\n\nInformation about changes to the agent are in NEWS.md.\n\n### Known issues:\n\n* The agent is only supported on Node.js 0.8 and newer. Some features may\n  behave differently between 0.8 and 0.10. The agent has been tested but not\n  extensively so on Node 0.11. The agent is optimized for newer versions of\n  Node.\n* There are irregularities around transaction trace capture and display.\n  If you notice missing or incorrect information from transaction traces,\n  let us know.\n* There are <del>over 20,000</del> <del>30,000</del> <del>40,000</del> <ins>*A\n  LOT* of</ins> modules on npm. We can only instrument a tiny number of them.\n  Even for the modules we support, there are a very large number of ways to use\n  them. If you see data you don't expect on New Relic and have the time to\n  produce a reduced version of the code that is producing the strange data, it\n  will be used to improve the agent and you will have the Node team's gratitude.\n* The CPU and memory overhead incurred by the Node agent is relatively minor\n  (~1-10%, depending on how much of the instrumentation your apps end up\n  using).  GC activity is significantly increased while the agent is active,\n  due to the large number of ephemeral objects created by metrics gathering.\n* When using Node's included clustering support, each worker process will\n  open its own connection to New Relic's servers, and will incur its own\n  overhead costs.\n\n### New Relic features available for other platforms not yet in Node.js\n\n* SSL-protected connections between the module and New Relic\n* high-security mode\n* Real User Monitoring (RUM)\n* cross-application tracing (depends on RUM)\n* custom parameters, metrics and instrumentation\n* slow SQL traces and explain plans\n* garbage collector instrumentation\n* thread profiling\n* X-ray transactions (depends on thread profiling)\n* capacity planning\n\n## LICENSE\n\nThe New Relic Node.js agent is free-to-use, proprietary software.  Please see\nthe full license (found in LICENSE in this distribution) for details on its\nlicense and the licenses of its dependencies.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/newrelic/node-newrelic/issues"
  },
  "bundleDependencies": [
    "bunyan",
    "continuation-local-storage"
  ],
  "_id": "newrelic@1.2.0",
  "_from": "newrelic@*"
}
